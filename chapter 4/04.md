# Taking Your Software into the Real World

Your application has to do more than work on your personal development machine.  
It must work when **real people** use it, in **real environments**, with **real-world problems**.

---

## Your Software Has a Context

Every application runs in a real-world context:

- Users make mistakes    
- Environments are imperfect
- Things fail in unexpected ways    

---

## Analysis Makes Software Real-World Ready

**Analysis** helps ensure your system works in a real-world context.

The key to preventing real-world issues is **anticipation**:

- Identify potential problems    
- Plan solutions    
- Solve issues **before** releasing the application    

---

## The Analysis Process

### 1. Identify the Problem
The first step in good analysis is identifying potential problems that could occur in the real world.

### 2. Plan a Solution
Once a problem is identified, determine what needs to change in **what the system does** to address it.

---

## Questions About Analysis

**Q: I came up with a different solution. Does that mean my solution is wrong?**  
**A:** No. As long as your solution solves the problem, it’s valid.  
In software, there are usually multiple ways to solve the same problem—there is rarely a single “right” answer.

---

**Q: I split one step in the use case into two steps instead of replacing it. Did I do something wrong?**  
**A:** No. Just as there are multiple solutions to a problem, there are multiple valid ways to express a solution in a use case.  
If the scenario is handled correctly, you have a working use case.

---

**Q: So use cases aren’t very precise, are they?**  
**A:** Actually, use cases are **very precise** about what the system must do.  
However, they don’t need to be formal or rigid in structure. The most important thing is that:

- They make sense to you    
- You can explain them to your team    
- Customers can understand them    

---

## Write Use Cases for Humans

Write your use cases in a way that makes sense to:

- You    
- Your team    
- Your boss    
- Your customers    

**Analysis and use cases** help demonstrate how your system behaves in the real world.

---

## Example: The Ultimate Dog Door (Version 3.0)

```text
What the Door Does

Main Path
1. The owner’s dog barks to be let out.
2. The bark recognizer hears a bark.
3. If it is the owner’s dog, the recognizer sends a request to open the door.
4. The dog door opens.
5. The dog goes outside.
6. The dog does his business.
   6.1 The door shuts automatically.
   6.2 The dog barks to be let back inside.
   6.3 The bark recognizer hears a bark again.
   6.4 If it is the owner’s dog, the recognizer sends a request to open the door.
   6.5 The door opens again.
7. The dog goes back inside.
8. The door shuts automatically.

Alternate Paths
2.1 The owner hears the dog barking.
3.1 The owner presses the remote control button.

6.3.1 The owner hears the dog barking again.
6.4.1 The owner presses the remote control button.
```

---

## What Analysis Is Really About

**Analysis ensures you didn’t forget anything that could prevent your software from working in the real world.**

---

## The Power of Loosely Coupled Applications

Delegation helps applications remain **loosely coupled**.

Loosely coupled systems:

- Have independent objects    
- Allow changes in one object without affecting others    
- Are easier to maintain and extend    

With delegation:

- You can change the implementation of one object (like `Bark`)    
- Other objects remain unaffected    
- Objects are shielded from implementation changes    

---

## UML Basics

### Example Class Diagram

```text
DogDoor

open: boolean
allowedBarks: Bark [*]

open()
close()
isOpen(): boolean
addAllowedBark(Bark)
getAllowedBarks(): Bark [*]
```

- Brackets indicate **multiplicity**    
- `[*]` means “any number”    

---

## Pay Attention to Nouns in Use Cases

An important insight:

- **Nouns** in a use case are often **candidates for classes**    
- **Verbs** are often **candidates for methods**    

This technique is called **textual analysis**.

---

### Important Rules

- You only create classes for things your system must represent    
- Not every noun becomes a class    
- External actors usually do not become classes    

---

## It’s All About the Use Case

### Questions

**Q: If I write use cases, will my software always work correctly?**  
**A:** Use cases are a great start, but not the whole story.  
Analysis helps you identify the classes and relationships needed to support the use cases.

---

**Q: I’ve never written use cases before and haven’t had issues. Do I really need them?**  
**A:** No, they are not mandatory. But if you want to:

- Reduce rework    
- Avoid embarrassing mistakes    
- Satisfy customers more consistently  
    Then use cases are extremely helpful.    

---

**Q: I’m not good at grammar. How can I do textual analysis?**  
**A:** You don’t need perfect grammar.  
Write in simple, conversational language. Then identify:

- The “things” (nouns)    
- The actions (verbs)    

That’s enough to get started.

---

## Reviewing Your Use Case

After writing a use case:

- Reread it    
- Make sure it makes sense    
- Ask others to review it    
- Validate it against real-world usage    

---

## Textual Analysis in Practice

- Textual analysis helps identify **what to focus on**    
- It reveals classes, attributes, and operations    
- It supports real-world behavior, not just code structure    

---

## Nouns and Verbs Recap

- **Nouns** are candidates for classes    
- **Verbs** are candidates for methods    
- Not all candidates become real code elements    

You usually don’t represent living things as classes unless the system must store long-term information about them.

---

## Class Diagrams Explained

- Solid lines represent **associations**    
- Associations indicate attributes by reference    
- The line goes from the referencing class to the referenced class    
- The attribute name is written near the target class    
- `*` means “many”    

---

## Class Diagrams Have Limits

Class diagrams:

- Provide a high-level overview    
- Help communicate system structure    
- Do not show method implementations    
- Do not show constructors    
- Do not capture all type details    

They are modeling tools, not coding instructions.

---

## Key Bullet Points

- Analysis ensures software works in real-world conditions.    
- Use cases should be understandable by all stakeholders.    
- Use cases describe **what** the system does, not **how**.    
- Each use case represents a single customer goal.    
- Multiple goals require multiple use cases.    
- Class diagrams provide a high-level system view.    
- Attributes map to member variables.    
- Operations map to methods.    
- Textual analysis translates use cases into code.    
- Nouns suggest classes; verbs suggest methods.